# 开发思想

## 代码质量分析
- 测试对代码的覆盖率
- 代码的格式是否清晰，有助于差异比较和可读性
- 是否很可能会出现NPE
- 是否忘记了域对象中的equals和hashCode方法

### Checkstyle
### FindBugs


## DDD 领域驱动设计

> [参考博客](http://kb.cnblogs.com/page/117717/)
[讨论](http://www.cnblogs.com/netfocus/p/3307971.html)
[基础](http://www.cnblogs.com/netfocus/archive/2011/10/10/2204949.html)

## TDD 测试驱动开发
![p276.jpg](https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Java7Developer/p276.jpg)

`TDD带来的好处`
- 更清晰的代码 只写需要的代码
- 更好的设计  有些开发人员管TDD叫测试驱动的设计
- 更出色的灵活性 TDD会鼓励按接口编码
- 更快速的反馈  不会直到系统上线才知道bug的存在

`红 - 绿 - 重构循环`
- 先编写不能通过测试的红色代码，就是一个简单的思路编写
- 然后修改，让测试通过，然后完善设计，进行重构编写，又进入红绿阶段，然后再重构

- 重构是为了通过测试你写的快速实现，重构减轻自己和别人的技术债务(临时凑合出来的设计或代码将来会付出更多的工作)
    - 有了通过测试， 就可以放心的重构，应该实现的业务逻辑就不可能会被忽视
- `多个测试用例 为了覆盖更多情况`
    - 按照TDD风格，就应该为之前编写的测试用例，进行多路径全覆盖，这个测试依然是红绿重构循环。

`深入思考 红 绿 重构循环`
- 失败测试（红）
    - 一些开发人员喜欢编写编译失败的测试，喜欢等到绿色步骤才提供实现代码
    - 也有一些开发人员喜欢先把测试调用的方法签名写出来，这样虽然编译能通过，但还是失败
- 通过测试
    - 这一步应该尽量少写代码，只要能测试通过即可。
- 重构
    - 许多地方需要重构，一般是： 去掉硬编码的变量，
    - 或把大方法拆分，对于面向对象来说应该遵循 SOLID 原则 [解释SOLID原则](/Java/模式之禅.md)
    - 可以把通用的设置和拆卸代码提取出来。可以重命名测试，以便于更准确地反应他的意图，根据静态分析工具例如`CheckStyle` `FindBugs`
![p283.jpg](https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Java7Developer/p283.jpg)
- 应该尽可能的遵守单个测试循环的开发模型，不要同时开多个测试循环，一堆红色

`JUnit`
- 主要的三个特性： 
    - 用于测试预期结果和异常的断言， assertEquals()
    - 设置和拆卸通用测试数据的能力， @Before @After
    - 运行测试套件的测试运行器

`一个基本的JUnit测试`
- @Before 标记方法， 测试运行前准备测试数据
- @After 标记方法， 测试运行完成后拆卸测试数据
- @Test 测试方法 例如：预期的异常`@Test(expected=NullPointException.class)`

### 测试技术
#### 测试替身
> 泛指任何出于测试目的的替换真实对象的假冒对象，为了解决测试代码的依赖项问题。四种方式： 虚设，伪装，存根，模拟

![p286](https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Java7Developer/p286.jpg)

##### 虚设对象
- 他是用来填充参数列表，填补那些总也不会用的必填域。大多数情况下，甚至可以传入null，就是把需要的参数虚拟出来
    - 只是为了避免NPE，让代码能跑起来

##### 存根对象
- 用来代替真实环境对象，需要有做出相同响应的对象，就是存根对象
    - 将一些外部类或三方资源，写一个类，以及对应的方法，来提供测试运行

##### 伪装替身
- 伪装替身，可以看作是存根的升级。他做的工作几乎是和生产代码是一样的，单位了满足测试需求也会使用便捷的方式
    - 例如 内存数据库HSQLDB 的使用，

##### 模拟对象
- 存根对象的调用通常会返回形同的结果。所以不能模拟任何与状态有关的行为，模拟对象就能够更好的胜任
    - 在准备要用的模拟对象时，告诉他会有哪些调用，以及对应的相应，模拟会和DI结合更好。可以用一个虚拟的对象，这个对象完全按照已知方式行动
- 模拟类库：[Mockito官网](http://mockito.org)
    - 调用mock()方法创建模拟对象，并将模拟目标类型的class对象作为参数传进去。
    - 然后要把模拟对象需要的行为记录下来，通过 when方法表明要记录哪些方法的行为，然后用thenReturn方法指定期望结果。


*******************
### Mockito学习







