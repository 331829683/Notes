====JDBC 和 Hibernate 比较================
JDBC使用其简洁精悍，最快，但是使用时接收数据以及多方面的比较麻烦
Hibernate单表操作是很便捷的，但是涉及到多表复杂操作时比较麻烦
====================配置流程===================如果后续需要添加表的话，就这个顺序============
  1  先有数据库和表，建立cfg.xml文件配置好数据库的基本参数
  2  使用工具建立POJO持久类
  3  导入Hibernate所必需JAR包，最好使用Myeclipse的配置，自己导包总有一堆错误
  4  使用MyEclipse自动创建hbm.xml文件，还有各种文件。配置好hbm文件里关于表间关系的映射，或者在Myeclipse配置时手动选择
  5  配置好DAO类中事务开启和关闭，以及各种所必需的配置
  6  调用DAO或者自己的Utils类，通过Hibernate来操作数据库

========================配置多对一的映射关系==================================================
1.在一的一方，修改xml文件，添加一个set 属性，表示 多方 的一个集合
2.在一的一方，修改POJO持久类文件，添加一个hashset，用来存储多方，添加setget方法，名字就是配置文件里添加的那个名字 注意修改构造器
3.在多的一方，修改xml文件，置换掉那个外键，换成many-to-one标签，里面写上外键的列
4.在多的一方，修改POJO持久类文件，添加一个一方的对象添加setget方法，名字就是配置文件里添加的那个名字  注意修改构造器
=============================使用多对一的技巧===============================================
1.添加记录：
	1.1.当需要添加一个多方时，一看成课程，多看成成绩。当然的首先得有相关课程，再添加成绩记录。
	1.2.那就先实例化一个课程对象，配置好信息
	1.3.实例化多个成绩实例，再 课程对象.get**Set().add(成绩对象); 将成绩对象添加到集合中，
	1.4.session.save(课程对象)；
注意：既然实现了这样的操作，那就说明了在实例化成绩的时候，不需要指定课程的值，那就需要添加一个构造器
2.删除记录
	2.1.如果删除一方，那就会将一删除，如果没有配置级联，就会将多方的外键置空，不会删除多方表
	2.2.如何通过一方修改多方的一条
			把一方的set中的要修改的一条，（查找之前需要对象 = session.load(对象.class,主键名)将多方的数据加载进来）注意多方不能有空列必须指定一个默认值（是和构造器有关么？）
			再查找出来，修改再update，新增也是如此
			增加多的一方的时候，就是在一方的set中新增一条记录，多方的操作都提现在了一方
===============异常=================
could not find a getter for ...
	原因：1 可能真的没写get方法
		2 *.hmb.xml文件中的属性名和pojo持久类中属性名不一致（一定不能在表名中添加下划线）
		3 方法名写错（基本不可能，都是自动生成的）
		4 setget方法中不允许两个连续大写字母
个人总结：
	当使用了没有主键的表，使用Myeclipse自动创建配置文件，使用自己的Table2Class来生成POJO持久类，
	就要继承对应的自动创建的抽象类，因为没有主键的表默认是将所有列看成一个主键，并且还会有添加一个id属性，
	这样也说明还有一点就是，这种表的字段不能有叫做id的列

	是不是可以不用手动去使用那个类，好像这里自动生成的一切都有，

	自动生成会生成：
		对应POJO的抽象类，hbm配置文件，以及默认的几个类，HibernateSessionFactory，IBaseHibernateDao，
		对应的Dao（添加的时候默认是没有使用事务，所以需要手动修改），
=========================================================

添加，删除，都是依据主键的，至少要初始化主键，当然还得满足数据库的要求，

