##【1.计算机组成与结构】
###【计算机中数据的表示】：

* 定点数：所有数据的小数点位置是固定的，小数点位置在数据最高位是定点小数，在最低位是定点整数，会有溢出的情况发生
* 浮点数：阶符，阶码，数符，尾数 组成， 尾数决定精度，阶码决定数据范围，最适合浮点数阶码的数字编码是移码
 - 数的机器码表示：
		原码：符号位表示该数的符号，0正1负 。原码中分+0和-0
		反码：符号位表示法和原码一样，正数反码是不变，负数要取反
		补码：最适合加减运算的数字编码
		移码：在数X上增加一个偏移量来定义的，常用于表示浮点数的阶码部分，如果机器字长n，规定偏移量是2的n-1次方，
			移码定义：[X移]=2(n-1次方)+X(-2(n-1)<=X<2(n-1))
 - 校验码：
		奇偶检验码：通过在编码中增加一位校验位来使编码中1的个数为奇数（奇校验）偶数（偶校验）
		海明码：在数据位中插入k个校验码，通过扩大码距来实现检错和纠错。数据位n 校验位k 2(k次方)-1>=n+k
		循环冗余校验码（CRC）:利用生成多项式的k个数据位和产生的r个校验码来进行编码，编码长度是k+r
 - 数制之间转换：2，8,10,16
####【CPU】：
- 运算器：执行所有算术运算，执行所有逻辑运算并进行逻辑测试（与或非，值比较，零值测试）
- 指令寄存器（IR）：CPU执行指令的时候，先把它从内存中加载到缓冲寄存器中，再送入IR暂存，指令译码器根据IR的内容来产生各种微操作指令
- 程序计数器（PC）：PC具有寄存信息和计数两种功能，又称为指令计数器。程序执行分为：顺序执行，转移执行。
		程序开始执行之前，将程序的起始地址送入PC，该地址在程序加载到内存时确定，因此PC的内容即是程序第一条指令的地址，
		执行指令时CPU会自动修改PC内容,确保永远是将要执行的下一条指令地址，顺序执行的话，只是简单的加一，
		转移指令时，指令地址根据当前地址加上一个向前或向后的偏移量得到，或者根据转移指令给出的直接转移地址得到
- 地址寄存器（AR）：AR保存当前CPU所访问的内存单元的地址。是为了解决内存和CPU速度不匹配的问题
- 指令译码器（ID）：指令分为操作码和地址码两部分，由该部分进行解析，协调硬件的运行
		时序控制逻辑：控制指令的执行时间顺序
		总线逻辑：为多个功能部件服务的信息通路的控制电路
		中断逻辑：控制各种中断请求，根据优先级来对中断请求排队。逐个交给CPU执行

- 寄存器组：
		专用寄存器，通用寄存器。上面的都是专用的，通用的可以给程序猿控制（提高速度，貌似没卵用）
####【存储系统】：
- 分类：
		读写存储器（RAM）：
		只读存储器（ROM）：
			固定只读储存器（ROM）
			可编程的只读存储器（PROM）
			可擦除的可编程只读存储器（EPROM）
			闪速存储器（Flash Memory）
- 相联存储器：    CAM
* Cache：高速缓冲存储器：为了解决内存和CPU速度不匹配的问题而存在
	
- 磁盘：
		磁盘存储器：由盘片，驱动器，控制器和接口组成。其存储容量有两种指标：格式化容量和非格式化容量。
			非格式化容量 = 面数*（磁道数/面）*内圆周长*最大位密度
			格式化容量 = 面数 *（磁道数/面）*（扇区数/道）*（字节数/扇区）
		光盘存储器：。。。
####【例题】内存按字节编址从 A5000H 到 DCFFFH的区域，其存储容量为224KB 若用16K * 4bit 的存储器芯片构成该内存，需要（ 28） 片
		（因为位数来计算的4bit的话，前面的单位是减半的,所以最好是使用bit来计算）
		解析：DCFFFH - A5000H = 38000H (16进制)  转换成二进制 0011 1000 0000 0000 0000b 去掉十个0 单位就成了kb,然后就是2的5,6,7次方求和
			得到224KB

####【输入输出系统】：
	DMA方式：
		无需CPU介入，流程：向CPU申请DMA传送，获取CPU允许后，DMA控制器接管系统总线的控制权；过程中不需要CPU结束回到CPU控制
####【总线系统】：
- 内部总线： 用于芯片一级的互联，分为芯片内总线和元件级总线。芯片内总线用在集成多芯片，元件级总线用于一块电路板内元器件的连接
- 系统总线：插件板一级的互联，用于构成计算机各组成部分（CPU，内存，接口）
- 外部总线：又称通信总线，用于设备一级的互联，通过该总线与其他设备进行信息与


####【加密算法】：
- 非对称加密的算法中使用了 私钥和公钥，私钥用于解密和签名，公钥用于加密和认证
- 数字证书：CA组织会给用户颁发数字证书，	由CA的私钥进行创建数字证书，数字签名，然后接收方使用CA的公钥来检查其真实性和数字签名
		（检查文件内容是否被篡改）

####【补码】：
	一般用于浮点数的阶码，简化计算机运算部分设计，因为 符号位可以运算，减作加处理
####【访问方式】：
	寻址方式访问： 直接 ， 顺序 ， 随机
	内容方式访问：相联存储器
##【2.程序语言】 
###【基本概念】：
####编译和解释：
- 编译：词法分析，语法分析，语义分析，中间代码生成，代码优化，生成目标代码（汇编语言/机器语言）
- 解释：分析部分：词法分析，语法分析，语义分析，然后把源程序翻译成中间代码（常用逆波兰表现形式，树，后缀式，四元，三元式）
			解释部分：对中间代码进行解释运行

	
####KMP模式匹配算法：
		求解模式串 p 中的next 函数值
		next={ 
			0  ， j=1;
			max{k|1<k<j,'p 1 p 2……p k-1 '='p j-k+1 …… p j-1'}；
			1  ，其他情况（没有符合要求的k）；
		}
		假设 p 为 abaabaca  那么函数值为01122341
		【答案的解释】：
		
		      j: 1 2 3 4 5 6 7 8
		      p: a b a a b a c a
		next(j): 0 1 1 2 2 3 4 1
		【自己的理解】：
			当 j=1 函数值必然是0
			当j=2 函数值必然是1
			当j=3 比较p1 和 p2 相同就是2 不同就是1
			当j=4 比较p1-> 和 <-p3 有几个相同k就是几个再加1，没有就是1
			当j=n 比较p1-> 和 <-p n-1 假设有m个相同 那么k=m+1,没有则k=1

	参数传递（值传递和引用传递）：
		
*****************************************************
##【2.程序设计语言】 
###高级程序设计语言翻译流程：
	词法分析，语法分析，词义分析，中间代码重构，目标代码生成（汇编语言，机器语言）
	高级程序设计语言使用的语法一般是 上下文无关法
###文法分析：
	是编译的一个理论支持
	推导和直接推导————规约和直接规约 相对应的
	文法G的开始符号推导出一串字符串，直到终结符，称为句型。只含终结符的句型是一个句子
	由开始符号，推导出的所有句子的全体是语言

###【考点】：正规式和DFA或NFA的转换
	DFA：有限自动机
	NFA：无限自动机
	自动机是用来读取输入的字符串并做对应的操作
	自动机 有初态和终态，初态到终态的任意一条路径就是一个完整的字符串


***************************************************************************
##【3.操作系统】



####定义
> 

####进程管理
####存储管理
####设备管理
####文件管理

* 位视图
	* 系统字长x，物理块大小y，那么第z号物理块需要第z/x个字来描述（注意是字长的区间）。容量为wG需要w×1024/y/x个字来表示

* 文件索引
	* 分直接索引项，一级间接索引项，二级间接索引项
	* 求逻辑块号区间，
	>直接：x<直接数
	>一级：直接索引项个数<=x<2^8+直接索引项个数
	二级：2^8+直接索引项个数<=x<2^16+2^8+直接索引项个数
	* 求指向的内存大小：
	>直接：直接数×数据块大小
	>一级：一级数×索引块大小/地址项大小×数据块大小
	>二级：二级数×索引块大小/地址项大小×索引块大小/地址项大小×数据块大小

* 路径问题
	* 全文件名，从根目录开始加上文件名 eg: \d\d\f.txt
	* 相对路径从当前路径(当前工作目录)开始的路径 eg:d\
	* 绝对路径从根目录开始的路径不含文件名 eg: \d\d\
####作业管理
* 调度级别：高级调度（作业调度），中级调度（交换调度），低级调度（进程调度）


##【4.软件工程基础知识】

* 软件生存周期
	* 可行性分析
	* 需求分析：功能，性能，数据，界面
	* 概要设计：分模块，定功能和关系，详细的数据库设计，数据结构设计
	* 详细设计：模块的详细算法设计，数据库的物理设计
	* 程序编码：
	* 软件测试
	* 维护：纠错维护，改错维护


* 软件生存周期模型
	* 瀑布模型：线性顺序模型，适用于对需求有完善了解，开发周期快
	* 原型/演化模型：通过原型来不断演化
	* 螺旋模型：综合了瀑布和原型的优点，增加了风险分析
	* 增量模型：先发布核心产品，然后根据需求不断增量，调试，直到完善
	* 喷泉模型：面向对象开发过程，以用户需求为动力，以对象为驱动的模型，使开发具有迭代性和无间隙性
	* V模型：瀑布模型演化而来，强调了软件开发过程中若干个测试级别。
 
* 项目管理
	* 启动
	* 度量
	* 估算
	* 风险分析
	* 进度安排
	* 追踪控制

* 成本估算
	* 估算策略
	>自顶向下 先确定整体时间，再按模块，分配时间
	>自底向上 按模块分析需求时间，再向上累积得出全部时间
	>差别估算 和类似项目比较
	* 估算方法
	>专家估算 专家一人确定
	>类推估算 自顶向下是类似项目总体参数对比，自底向上是两个相似的功能单元对比
	>算式估算 上面两种带有主观性，这个是为了消除主观性

* 成本估算模型
	* IBM 基于60项目的静态模型
	* Putnam（普特南）模型：动态多变量模型
	* COCOMO模型：
		* 基本COCOMO模型 静态单变量模型
		* 中级COCOMO模型 静态多变量模型
		* 详细COCOMO模型 将系统分为系统，子系统，模块三层次，
	      包含了中级并考虑了软件开发流程中每一步的成本驱动影响

* 风险分析
	* 风险识别 ：
	* 风险评估 ：成本，进度，性能是三种典型的风险参考水准
	* 风险控制 ：
	* 风险策略管理
		* 避免风险
		* 控制风险
		* 分散和中和风险
		* 转移风险
* 进度管理
	* Gantt 甘特图：描述了任务的开始和结束，并行关系，但是不能体现依赖关系
	* PERT技术：
		* 关键路径是耗时最长的路径
		* 任务松弛时间 = 最迟开始时间 - 任务最早开始时间
		> 最迟开始时间 = 从终点往回推，用最长时间（关键路径耗时）减去终点到该任务的时间
		* 任务的延时，推迟问题。应当计算由于各种原因引起的推迟路径，计算出总时间，减去原时间，不能只看一段。
* 文档管理
	* 高质量文档
		* 针对性 分清阅读对象，来适应他们需求
		* 精确性 确切的语句，不能有二义性
		* 清晰性 简明，加以图表
		* 灵活性 各个软件项目，规模复杂性有很多差别，但是能一律看待
* 人员管理
	* 主程序员组 ：住程序员，后备，资料员，若干程序员
	* 无主程序员组 ：相互平等，调动积极性，但是权责问题不明确
	* 层次式程序员组 ：组长，高级程序员，普通程序员。适合大型项目

* 
**************************************************
##【5.系统开发与运行】
 
**************************************************
##【6.网络与多媒体基础知识】
 
**************************************************
##【7.数据库技术，基础】
 
**************************************************
##【8.算法与数据结构】
 
**************************************************
##【9.面向对象技术】
 
**************************************************
##【10.标准化与只是产权】
 
**************************************************
##【11.专业英语】
 
**************************************************
##【12.数据流图】
 
**************************************************
##【13.UML设计与分析】
 
**************************************************
##【14.数据库设计】
 
**************************************************
##【15.数据结构与算法】
 
**************************************************
##【16.C++程序设计】
 
**************************************************
##【17.Java程序设计】
 
**************************************************

##  模拟题错题记录
