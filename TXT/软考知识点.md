##【1.计算机组成与结构】
###【计算机中数据的表示】：

* **定点数**：所有数据的小数点位置是固定的，小数点位置在数据最高位是定点小数，在最低位是定点整数，会有溢出的情况发生
* **浮点数**：阶符，阶码，数符，尾数 组成， 尾数决定精度，阶码决定数据范围，最适合浮点数阶码的数字编码是移码
 - 数的机器码表示：
	- 		**原码**：符号位表示该数的符号，0正1负 。原码中分+0和-0
	- 		**反码**：符号位表示法和原码一样，正数反码是不变，负数要取反
	- 		**补码**：最适合加减运算的数字编码
	- 		**移码**：在数X上增加一个偏移量来定义的，常用于表示浮点数的阶码部分，如果机器字长n，规定偏移量是2的n-1次方，
			移码定义：[X移]=2(n-1次方)+X(-2(n-1)<=X<2(n-1))
* **校验码**：
	* **奇偶检验码**：通过在编码中增加一位校验位来使编码中1的个数为奇数（奇校验）偶数（偶校验）
	* **海明码**：在数据位中插入k个校验码，通过扩大码距来实现检错和纠错。数据位n 校验位k 2(k次方)-1>=n+k
	* **循环冗余校验码**（CRC）:利用生成多项式的k个数据位和产生的r个校验码来进行编码，编码长度是k+r
 - 数制之间转换：2，8,10,16

####【CPU】：
- **运算器**：执行所有算术运算，执行所有逻辑运算并进行逻辑测试（与或非，值比较，零值测试）
- 指令寄存器（IR）：CPU执行指令的时候，先把它从内存中加载到缓冲寄存器中，再送入IR暂存，指令译码器根据IR的内容来产生各种微操作指令
- **程序计数器**（PC）：PC具有寄存信息和计数两种功能，又称为指令计数器。程序执行分为：顺序执行，转移执行。
	* 程序开始执行之前，将程序的起始地址送入PC，该地址在程序加载到内存时确定，因此PC的内容即是程序第一条指令的地址，
	执行指令时CPU会自动修改PC内容,确保永远是将要执行的下一条指令地址，顺序执行的话，只是简单的加一，
	转移指令时，指令地址根据当前地址加上一个向前或向后的偏移量得到，或者根据转移指令给出的直接转移地址得到
- **地址寄存器**（AR）：AR保存当前CPU所访问的内存单元的地址。是为了解决内存和CPU速度不匹配的问题
- **指令译码器**（ID）：指令分为操作码和地址码两部分，由该部分进行解析，协调硬件的运行
	- 		时序控制逻辑：控制指令的执行时间顺序
	- 		总线逻辑：为多个功能部件服务的信息通路的控制电路
	- 		中断逻辑：控制各种中断请求，根据优先级来对中断请求排队。逐个交给CPU执行

- **寄存器组**：
		专用寄存器，通用寄存器。上面的都是专用的，通用的可以给程序猿控制（提高速度，貌似没卵用）
####【存储系统】：
- **分类**：
	* 读写存储器（RAM）：
	* 只读存储器（ROM）：
		- 固定只读储存器（ROM）
		- 可编程的只读存储器（PROM）
		- 可擦除的可编程只读存储器（EPROM）
		- 闪速存储器（Flash Memory）
- **相联存储器**：    CAM
* Cache：高速缓冲存储器：为了解决内存和CPU速度不匹配的问题而存在
	
- **磁盘**：
	* 磁盘存储器：由盘片，驱动器，控制器和接口组成。其存储容量有两种指标：格式化容量和非格式化容量。
		* 非格式化容量 = 面数*（磁道数/面）*内圆周长*最大位密度
		* 格式化容量 = 面数 *（磁道数/面）*（扇区数/道）*（字节数/扇区）
	* 光盘存储器：。。。

####【例题】内存按字节编址从 A5000H 到 DCFFFH的区域，其存储容量为224KB 若用16K * 4bit 的存储器芯片构成该内存，需要（ 28） 片
		（因为位数来计算的4bit的话，前面的单位是减半的,所以最好是使用bit来计算）
		解析：DCFFFH - A5000H = 38000H (16进制)  转换成二进制 0011 1000 0000 0000 0000b 
		去掉十个0 单位就成了kb,然后就是2的5,6,7次方求和   得到224KB

####【输入输出系统】：
	DMA方式：
		无需CPU介入，流程：向CPU申请DMA传送，获取CPU允许后，DMA控制器接管系统总线的控制权；过程中不需要CPU结束回到CPU控制
####【总线系统】：
- **内部总线**： 用于芯片一级的互联，分为芯片内总线和元件级总线。芯片内总线用在集成多芯片，元件级总线用于一块电路板内元器件的连接
- **系统总线**：插件板一级的互联，用于构成计算机各组成部分（CPU，内存，接口）
- **外部总线**：又称通信总线，用于设备一级的互联，通过该总线与其他设备进行信息与


####【加密算法】：
- **非对称加密的算法中使用了** 私钥和公钥，私钥用于解密和数字签名，公钥用于加密和认证证书的真实性
- **数字证书**：CA组织会给用户颁发数字证书，	由CA的私钥进行创建数字证书，数字签名，然后接收方使用CA的公钥来检查其真实性和数字签名
		（检查文件内容是否被篡改）

####【补码】：
	一般用于浮点数的阶码，简化计算机运算部分设计，因为 符号位可以运算，减作加处理
####【访问方式】：
	寻址方式访问： 直接 ， 顺序 ， 随机
	内容方式访问：相联存储器
*************************************************************************
##【2.程序设计语言】
###【基本概念】：
####编译和解释：
- **编译**：词法分析，语法分析，语义分析，中间代码生成，代码优化，生成目标代码（汇编语言/机器语言）
- **解释**：分析部分：词法分析，语法分析，语义分析，然后把源程序翻译成中间代码（常用逆波兰表现形式，树，后缀式，四元，三元式）
			解释部分：对中间代码进行解释运行

	
####KMP模式匹配算法：
		求解模式串 p 中的next 函数值
		next={ 
			0  ， j=1;
			max{k|1<k<j,'p 1 p 2……p k-1 '='p j-k+1 …… p j-1'}；
			1  ，其他情况（没有符合要求的k）；
		}
		假设 p 为 abaabaca  那么函数值为01122341
		【答案的解释】：
		
		      j: 1 2 3 4 5 6 7 8
		      p: a b a a b a c a
		next(j): 0 1 1 2 2 3 4 1
		【自己的理解】：
			当 j=1 函数值必然是0
			当j=2 函数值必然是1
			当j=3 比较p1 和 p2 相同就是2 不同就是1
			当j=4 比较p1-> 和 <-p3 有几个相同k就是几个再加1，没有就是1
			当j=n 比较p1-> 和 <-p n-1 假设有m个相同 那么k=m+1,没有则k=1

	参数传递（值传递和引用传递）：
		
*****************************************************
###高级程序设计语言翻译流程：
	词法分析，语法分析，词义分析，中间代码重构，目标代码生成（汇编语言，机器语言）
	高级程序设计语言使用的语法一般是 上下文无关法
###文法分析：
	是编译的一个理论支持
	推导和直接推导————规约和直接规约 相对应的
	文法G的开始符号推导出一串字符串，直到终结符，称为句型。只含终结符的句型是一个句子
	由开始符号，推导出的所有句子的全体是语言

###【考点】：正规式和DFA或NFA的转换
	DFA：有限自动机
	NFA：无限自动机
	自动机是用来读取输入的字符串并做对应的操作
	自动机 有初态和终态，初态到终态的任意一条路径就是一个完整的字符串
![](http://i.imgur.com/7ZxejMD.png)
***************************************************************************
##【3.操作系统】

####定义
* **分类**
	* 批处理
	* 实时
	* 嵌入式
	* 个人
	* 网络
	* 分布式

* **特性**
	* 并发
	* 共享
	* 虚拟性
	* 确定性

* **资源管理**
	* 文件管理
	* 存储管理
	* 处理机管理
	* 设备管理
	* 作业管理


####进程管理
* 同步是进程间的直接制约---：进程合作的等待问题
* 互斥是进程间的间接制约---：进程竞争一个资源（进程独占）
* PV操作：
	* 实现进程同步，互斥的常用方法
	* P操作，S:=S-1 如果S>=0，执行P操作的线程继续执行，否则阻塞
	* V操作，S:=S+1 如果S>0 执行S操作的线程就会继续，否则从阻塞队列中唤醒一个线程

* **进程资源图**（分辨死锁，线程竞争）灵活辨别是否是安全序列
	* 资源=（线程数-1）×（最大-1）+最大×1
	* 不发生死锁的临界：即有一个不是阻塞，其他的线程都是只差一个资源（阻塞等待中）

####存储管理
####处理机


####设备管理
* **磁盘读取**
	* SCAN 扫描算法 磁头按当前运动方向，至最大/最小再逆序折回读取
	* CSCAN 单向扫描算法 磁头按当前运动方向，至最大/小，立马到最小/大又按初始的运动方向进行读取
####文件管理

* **位视图**
	* 系统字长x，物理块大小y，那么第z号物理块需要第z/x个字来描述（注意是字长的区间）。容量为w(G)需要w×1024/y/x个字来表示

* **文件索引**
	* 分直接索引项，一级间接索引项，二级间接索引项
	* 求逻辑块号区间，
    	* 直接：x<直接数
    	* 一级：直接索引项个数<=x<2^8+直接索引项个数
    	* 二级：2^8+直接索引项个数<=x<2^16+2^8+直接索引项个数
	* 求指向的内存大小：
    	* 直接：直接数×数据块大小
    	* 一级：一级数×索引块大小/地址项大小×数据块大小
    	* 二级：二级数×索引块大小/地址项大小×索引块大小/地址项大小×数据块大小

* **路径问题**
	* 全文件名，从根目录开始加上文件名 eg: \d\d\f.txt
	* 相对路径从当前路径(当前工作目录)开始的路径 eg:d\
	* 绝对路径从根目录开始的路径不含文件名 eg: \d\d\
####作业管理
* 调度级别：高级调度（作业调度），中级调度（交换调度），低级调度（进程调度）


##【4.软件工程基础知识】

* **软件生存周期**
	* 可行性分析
	* 需求分析：功能，性能，数据，界面
	* 概要设计：分模块，定功能和关系，详细的数据库设计，数据结构设计
	* 详细设计：模块的详细算法设计，数据库的物理设计
	* 程序编码：
	* 软件测试
	* 维护：纠错维护，改错维护


* **软件生存周期模型**
	* 瀑布模型：线性顺序模型，适用于对需求有完善了解，开发周期快
	* 原型/演化模型：通过原型来不断演化
	* 螺旋模型：综合了瀑布和原型的优点，增加了风险分析
	* 增量模型：先发布核心产品，然后根据需求不断增量，调试，直到完善
	* 喷泉模型：面向对象开发过程，以用户需求为动力，以对象为驱动的模型，使开发具有迭代性和无间隙性
	* V模型：瀑布模型演化而来，强调了软件开发过程中若干个测试级别。
 
* **项目管理**
	* 启动
	* 度量
	* 估算
	* 风险分析
	* 进度安排
	* 追踪控制

****

####成本估算
* **估算策略**
	* 自顶向下 先确定整体时间，再按模块，分配时间
	* 自底向上 按模块分析需求时间，再向上累积得出全部时间
	* 差别估算 和类似项目比较
* **估算方法**
	* 专家估算 ：专家一人确定
	* 类推估算 ：自顶向下是类似项目总体参数对比，自底向上是两个相似的功能单元对比
	* 算式估算 ：上面两种带有主观性，这个是为了消除主观性
* **成本估算模型**
	* IBM 基于60项目的静态模型
	* Putnam（普特南）模型：动态多变量模型
	* COCOMO模型：
		* 基本COCOMO模型 静态单变量模型
		* 中级COCOMO模型 静态多变量模型
		* 详细COCOMO模型 将系统分为系统，子系统，模块三层次，
	      包含了中级并考虑了软件开发流程中每一步的成本驱动影响

****

* **风险分析**
	* 风险识别 ：
	* 风险评估 ：成本，进度，性能是三种典型的风险参考水准
	* 风险控制 ：
	* 风险策略管理
		* 避免风险
		* 控制风险
		* 分散和中和风险
		* 转移风险
* **进度管理**
	* Gantt 甘特图：描述了任务的开始和结束，并行关系，但是不能体现依赖关系
	* PERT技术：
		* 关键路径是耗时最长的路径
		* 任务松弛时间 = 最迟开始时间 - 任务最早开始时间
		> 最迟开始时间 = 从终点往回推，用最长时间（关键路径耗时）减去终点到该任务的时间
		* 任务的延时，推迟问题。应当计算由于各种原因引起的推迟路径，计算出总时间，减去原时间，不能只看一段。
* **文档管理**
	* 高质量文档
		* 针对性 分清阅读对象，来适应他们需求
		* 精确性 确切的语句，不能有二义性
		* 清晰性 简明，加以图表
		* 灵活性 各个软件项目，规模复杂性有很多差别，但是能一律看待
* **人员管理**
	* 主程序员组 ：住程序员，后备，资料员，若干程序员
	* 无主程序员组 ：相互平等，调动积极性，但是权责问题不明确
	* 层次式程序员组 ：组长，高级程序员，普通程序员。适合大型项目

* **软件过程管理**
	* UP的结构
		* 初始阶段： 建立商业案例，确定项目边界
		* 精化阶段： 分析问题领域，建立体系结构基础
		* 构建阶段： 剩余的构建和功能开发，集成为产品，此时是beta版
		* 移交阶段： 测试，基于反馈调整，交付系统

####敏捷开发方法
* **极限编程**
	* 将项目细分小模块，迭代编写，
	* 先测试再编程
	* 结对编程
* **水晶法** ： 每一个项目都要有一套不同的策略和方法
* **并列争求法** ：该方法使用迭代的方法，将30天一次的迭代，称为冲刺
* **自适应软件开发方法**： 
	* 1.一个使命作为指导
	* 2.特征视为客户的关键点
	* 3.过程中的等待很重要
	* 4.变化视为实际的调整，不看做改正
	* 5.确定的交付时间，迫使开发人员考虑每一个版本的关键需求
	* 6.风险也在考虑范围内

****

* **CMM 能力成熟度模型**
	*  五个级别：
		*  初始级
		*  可重复级
		*  已定义级
		*  定量管理级
		*  优化级
	* CMMI 的任务是将已有的CMM模型结合在一起，构造为集成模型
* **程序流程图**
	* 简单路径：个人看法，看到选择结构就加一，初始是一个路径（输入到输出）
	* McCabe度量法：V(G)=m-n+2p 
		* V(G)：路径复杂度
		* m:所有流程线
		* n:所有节点数
		* p:该有向图的强联通分量（图是有几块组成）

****

* **ISO/IEC软件质量模型中**，
	* 可靠性：
		* 成熟性，容错性，易恢复性，兼容性
	* 可维护性：
		* 易分析性：为 判定软件修改所需的努力
		* 易改变性：进行修改，适应环境变化所需的努力
		* 稳定性：与修改造成的风险后果相关
		* 易测试性：与确认修改所需的努力。

**************************************************
##【5.系统开发与运行】
* **结构化分析和设计**
	* 结构化分析方法： 是基于数据流的方法
	* 数据流图 DFD
		* 数据流：箭头表示，数据的流向
		* 加工：圆或圆框，对数据进行处理的单元接受输入数据，产生输出
		* 数据存储：信息的静态存储
		* 实体：矩形，分数据源（源头），数据潭（终点）
	* 数据字典
		* 是以准确的方式定义所有数据流和数据存储，含三类：数据流条目，数据存储条目，数据项条目
	* 加工逻辑描述
		* 也称 小说明，用来描述加工的，加工逻辑即 做什么
* **数据流图的设计原则**
	* 数据守恒原则：任何一个加工，其所有输出的数据都是从输入数据流中获得
	* 守恒加工原则：对同一个加工来说，输入输出的名字必须不同，即使组成成分是一样的
	* 每一个加工必须有输入流和输出流
	* 外部实体和数据存储之间，自身也是，！不能有数据流！
	* 父图与子图平衡原则：父图子图的输入输出流，必须一致，该原则不存在于一张图
	* 数据流必须和加工有关，必须经过加工
* 数据流图的顶层数据流图，描述了系统的输入和输出，只有一个加工表示系统

####【模块】
* **模块独立**：
	* 耦合：模块之间的紧密程度
	* 聚合：模块内部各元素之间联系的紧密程度

* **内聚类型**（由高到低）
	* 功能内聚：完成一个单一的功能，各个部分缺一不可
	* 顺序内聚：处理元素相同，而且必须顺序执行
	* 通信内聚：所有处理元素集中在一个数据结构的区域上
	* 过程内聚：与处理元素相关，而且必须按待定的次序执行
	* 瞬时内聚：所包含的任务必须在同一时间间隔内执行（初始化模块）
	* 逻辑内聚：完成逻辑上相关的一组任务
	* 偶然内聚：完成一组没有关系或松散的任务

* **耦合类型**（由低到高）
	* 无直接耦合：两个模块没有任何关系
	* 数据耦合：两个模块间只是参数传递简单数据
	* 标记耦合：两个模块都和一个数据结构有关
	* 控制耦合：两个模块间传递的信息中有控制信息
	* 公共耦合：两个或多个模块，通过引用一个公共区的数据而发生作用
	* 内容耦合：最高的耦合度
		* 当一个模块使用另一个模块内部的控制和控制信息等数据；
		* 一个模块直接转移到另一个模块；

****

####【测试方法】
* **白盒测试**：由低到高
	* 语句覆盖
		* 冒泡排序只要一个用例就可以达到语句覆盖
	* 判定覆盖
	* 条件覆盖
	* 判定/条件覆盖
	* 条件组合覆盖
	* 路径覆盖： 使用 McCabe度量法 计算路径复杂度，一个路径一个测试用例。
		* 但是折半查找最少两个，和流程图无关，因为结果是互斥的
		
* **黑盒测试**：
	* 等价类划分：将所有可能输入的数据划分为若干子集，然后从每一个子集中选取少数具有代表性的数据作为测试用例
	* 边界值分析
	* 错误猜测
	* 因果图
* **回归测试**：修改了旧代码后，重新测试，确认修改没有引入其他错误或导致原有代码错误
* **软件测试步骤**：
* **单元测试**，集成测试，确认测试，系统测试

****

* **软件维护**：
	* 改正性维护：修复错误 约占20%
	* 适应性维护：适应环境 约占25%
	* 完善性维护：增加功能，提高性能 约占50%
	* 预防性维护：为以后增加功能准备


**************************************************
##【6.网络与多媒体基础知识】近几年没有考题
* **SO/OSI七层网络体系结构** 1979年建立
	* 应用层
	* 表示层
	* 会话层
	* 传输层
	* 网络层
	* 数据链路层
	* 物理层
	

* **TCP/IP协议**：
	* 应用层
	* 传输层
	* IP层
	* 网络接口层：包含了OSI模型中的数据链路层，物理层

* 【网络协议】：
	* **LAN模型**：IEEE802局域网标准，定义了物理层和数据链路层，数据链路层又分两个子层
	* **1. 物理层**
	* LLC ： 提供两种控制类型，面向连接，非连接
	* MAC ： 控制对传输介	* TCP/IP协议簇质的访问

	* **2. 网络接口层协议**：负责管理为物理网络准备数据
	* IP（网络层）：网络之间互联的协议
	* ARP/RARP（网络层）：硬件MAC到IP/IP到硬件MAC的转换协议
	* ICMP（网络层）：网际控制报文协议
	* TCP（传输层）：传输控制协议 ，可靠的面向连接的服务
	* UDP（传输层）：用户数据包协议 ，不可靠的面向无连接的
	* 应用层协议：NFS,Telnet,SMTP,DNS,SNMP,FTP

****
####【硬件设备】
* **物理层互联设备**
	* 中继器 Repeater ： 常用于两个网络节点之间物理信号的双向转发工作
	* 集线器 Hub ：对接收到的信号进行再生整形放大，以扩大网络传输距离（是相当于将各个主机直接联通，在逻辑上构成了一个共享的总线，所以就构成了一个广播域，一个冲突域）

* **数据链路层互联设备**
	* 网桥 Bridge ：扩展网络的距离和范围，提高网络性能，可靠性，安全性
	* 交换机 Switch ：基于mac地址的识别，有记录mac地址的地址表（为通信的两台主机建立专用的通道，所以是交换机的没一个接口都是自己的一个冲突域，所有接口和主机构成了一个广播域）

* **网络层互联设备**
	* 路由器 Router ：连接多个逻辑上分开的网络（） 

* **应用层互联设备**
	* 网关 GateWay ：当连接不同类型，并且协议差别大的网络时，要选用网关设备 功能：协议转换，数据分组。

****

* **DHCP** 客户端可以从DHCP服务器，获得DHCP服务器的IP地址，DNS服务器的IP地址，默认网关的IP地址，但是不能获得WEB服务器的IP地址。
* **NAT桥接**：内网主机发送数据时，NAT将源IP从内网转换成外网址。接受数据时将目的IP（外网）转换成内网网址

****

* **安全认证**：
	* PPP的NCP可以承载多种协议的三层数据包
	* PPP使用LCP控制多种链路的参数（建立，认证，压缩）
* **PPP中的安全认证类型**：
	* pap认证 是通过二次握手建立认证（明文不加密）
	* chap认证 是挑战握手认证，三次握手建立认证（密文采用MDS加密）
	* PPP的双向认证 采用的是chap的主验证风格
	* PPP的加固认证 采用的是两种 （pap chap）同时使用
* **无线接口标准** :国际电信联盟，在2000年5月 确定W-CDMA，CDMA2000，TDS-CDMA三大主流无线接口标准
	* 中国独自制定的3G标准是 TD-SCDMA

****

* IP地址
* IP地址全0是指任意网络，全1是指当前子网的广播地址

****

####【网络安全】
* **防火墙技术分类**
    * 包过滤型防火墙
    * 代理服务器型防火墙
    * 监测型防火墙
* **防火墙体系结构**
    * 包过滤路由器结构
    * 双穴主机结构
    * 屏蔽主机网关结构
    * 被屏蔽子网结构
* **防火墙的工作模式**
    * 透明模式
    * NAT模式
    * 路由模式
* **防火墙的安全策略**
    * 禁止外部网络ping内部网络
    * 禁止外部网络非法用户访问内部网络和DMZ区应用服务器
    * 禁止外部网络用户对内部网络HTTP、FTP、TELNET、TRACEROUTE、RLOGIN等端口访问
    * 禁止DMZ区的应用服务器访问内部网络
    * 允许外部网络用户使用DMZ区的应用服务：HTTP,HTTPS,POP3
    * 允许DMZ区内的工作站与应用服务器访问Internet
    * 允许内部企业用户访问DMZ区的应用服务：DNS,POP3,SMTP,HTTP,HTTPS,FTP等
    * 允许内部企业网络访问或通过代理访问外部网络

****

* **模拟和数字信号的转换**：A/D是模拟到数字和D/A 数字到模拟

* **声音数字化**：
    * 采样：把时间连续的模拟信号 转换成时间离散幅度连续的信号
    * 量化：把幅度上连续取值的每一个样本，转换成离散值表示，量化也称A/D转换
    * 编码：数据压缩和编码
* **图形和图像**
    * **色彩三要素**：亮度，色调，饱和度
    * **三基色原理**：红 绿 蓝 
    * **彩色空间**：
        * RGB彩色空间：
        * CMY彩色空间：
        * YUV彩色空间：
    * **图形数据的表示**：
        * 矢量：用指令描述构成一幅图像
        * 位图：使用像素点来描述
    * **图像的属性**：
        * 分辨率：像素数目
        * 图像深度（值域）：确定了图像的每个像素可能有的颜色数，或者确定灰度图像的每个像素可能有的灰度级数。 它决定了彩色图像中的可能出现的最多颜色数，或者灰度图像中的最大灰度等级
        * 真彩色和伪彩色：真彩色是像素值中存有RGB三个分量值，伪彩色是将像素值作为地址索引，在彩色查找表中查找这个像素实际的RGB值
        * 图像的压缩编码：有损（JPEG）和无损压缩
* **图像文件格式**：
    * BMP：windows采用的图像文件格式，采用位映射存储格式，不压缩
    * GIF：无损压缩算法，可以显示简单动画
    * TIFF：
    * PCX
    * PNG：作为GIF的替代品而开发的，压缩采用的是LZ77无损压缩算法
    * JEPG：有损压缩算法，压缩比例大
    * Targe
    * WMF：只在windows中使用，保存的是函数调用信息
    * EPS
    * DIF：AutoCAD中常采用

####动画与视频
* **彩色电视的制式**：NTCS和PAL，前者用于日美加拿大，墨西哥等，后者用于中国，欧洲，中东
* **视频文件格式**：GIF,FLC/FLI,AVI,.MOV/QT
* **视频压缩标准**：H.261,JEPG,MPEG,DVI

####媒体类型：
* **感觉媒体**：使人感觉得到的媒体，音乐，图像等
* **表示媒体**：为加工处理传输感觉媒体而来的一种媒体，例如文本编码，图像编码，声音编码
* **表现媒体**：进行信息的输入输出的媒体：键盘，鼠标，扫描仪，话筒
* **存储媒体**：存储表示媒体的物理介质，硬盘，光盘
* **传输媒体**：电缆，光缆等
* 通常没有特殊说明的情况下，信息媒体就是指感觉媒体

**************************************************
##【7.数据库技术，基础】

####关系模式（不是指表，但是是包含了表，在表的层次以上）
* **一个关系模式应该是五元组** R（U,D,DOM,F）
    * R 符号化的元组语义
    * U 一组属性
    * D 是属性组U中的属性所来自的域
    * DOM 为属性到域的映射
    * F 为属性组U上的一组数据依赖
* 一般使用三元组 R <U,F>
* 当且仅当 U 上的一个关系r满足F时，r称为关系模式R<U,F>的一个关系。


####【数据依赖】
* 数据依赖是一个关系内部属性与属性之间的一种约束关系
* 1.**函数依赖** FD
    * 若U的子集X,Y，X和Y形成唯一标识，X函数确定Y，Y函数依赖于X。记X -> Y
    * 非平凡的函数依赖：X->Y 但是Y不属于X
    * 平凡的函数依赖：X->Y Y属于X
    * X 称为该函数依赖的决定属性，决定因素
    * X->Y 并 Y->X 则 X<-->Y
* 2.**多值依赖** MVD
* 1.1 完全函数依赖：X->Y 并且X的真子集D 都存在子集 D不能->Y。
* 1.2 部分函数依赖：X->Y 但是Y不完全函数依赖于X 。
* 1.3 传递函数依赖：X->Y（Y不属于X），Y不能->X， Y->Z（Z不属于Y）则称Z对X传递函数依赖

####【码】
* 设 K是R<U,F>中的属性或属性组，K能完全函数依赖推出U，则K是R的候选码。
* 如果上面的K是部分函数依赖，则称K是超码，候选码是最小的超码
* 主属性：被包含在任一候选码中的属性
* 非主属性：主属性的补集
* 全码：所有属性一起构成了码
* 外码：关系模式R中属性或属性组 X 不是R的码，但是X是另一个关系模式的码，则X是外码

####【范式】 应用于关系模式R<U,F>
* **1NF**：每一个分量都是不可分的数据项
* **2NF**：R满足1NF，且每一个非主属性完全函数依赖任何一个候选码
* **3NF**：R满足1NF，R中不存在码X，属性组Y以及非主属性Z（Z不属于Y） 使得X->Y Y->Z Y不->X 则称R是满足3NF（取消了传递函数依赖）
* **BCNF**：满足1NF，若X->Y且Y不属于X时，X必含有码，则R是满足BCNF
    * 所有非主属性对每一个码都是完全函数依赖
    * 所有主属性对每一个不包含它的码也是完全函数依赖
    * 没有任何属性完全依赖于非码的任何一组属性

####闭包
* 在关系模式R<U,F>中为F所逻辑蕴含的函数依赖的全体叫做F的闭包
* 设F是属性集U上的一组函数依赖，X,Y属于U，![](http://i.imgur.com/pChaMD3.png)={A|X->A} 称为![](http://i.imgur.com/pChaMD3.png)属性集X关于函数依赖集F的闭包

####模式分解
* 具有无损连接性（粗略概述：不减少字段和改变元组）
* 要保持函数依赖（子模式里满足依赖关系）
* 既要保持函数依赖性，又要具有无损连接性
* 通过使用模式分解能提高关系模式能满足的范式等级

**************************************************
##【8.算法与数据结构】
 
**************************************************
##【9.面向对象技术】
* **面向对象** = 对象+分类+继承+用消息通信
* **对象**：对象名，属性，操作
    * 特性：清晰的边界，良好定义的行为，可扩展性
* **类**：对象的抽象
* **消息**：对象之间通信的一种构造（对象调用方法）

####三大特性
* **继承**：可分单重继承，多重继承
* **多态**：
    * 参数多态：指同一个对象，函数，过程能以一致的形式用于不同类型
    * 包含多态：子类型化，即一个类型是另一个类型的子类型
    * 过载多态：同一变量被用来表示不同的功能
    * 强制多态：通过语义操作，把一个变元的类型加以变换，以符合函数要求，不强转就会使得函数错误
* **封装**：目的是将定义和数据分离，保护数据不被对象使用者直接存取

****

* **重置**（覆盖）：指在子类中改变父类中既有函数行为的操作，通过一种动态绑定是的子类继承父类的前提下，用适合自己要求的实现去覆盖父类的实现
* **重载**：子类保留父类的函数名，但使用不同类型的参数
* **动态绑定**：以函数调用和函数本体的关联为基础，绑定动作在运行期才根据对象类型运行。也称后期绑定（应该就是根据参数来判断实例化什么对象或执行对应的方法）
* **静态绑定**：编译过程中，将函数调用与响应调用所需的代码结合的过程

****

###关联关系：
* **泛化** ： 类和类之间的继承关系，接口之间的继承关系，类和接口的实现关系，泛化关系是从子类指向父类
* **关联** ： 当一个对象的实例和另一个对象的实例存在固定的对应关系时，关联体现的是两个类或者类和接口之间语义级别的一种强依赖关系，可以单或双向。
* **聚合** ： 体现的是整体与部分的关系，整体与部分之间是可分离的，他们各自有各自的声明周期，部分可以属于多个整体对象，也可以为多个整体对象共享
* **组合** ： 也称强聚合，整体和部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束
 
####面向对象分析（OOA）：
* 1.分析问题域，建立用例模型。
* 2.发现和定义对象和类
* 3.识别对象的内部特征
* 4.识别对象的外部联系
* 5.识别对象之间的交互

****

* OOA模型（面向对象分析）：
    * **5个层次**：
        * 主体层
        * 对象类层
        * 结构层
        * 属性层
        * 服务层
    * **5个活动**：
        * 标识对象类
        * 标识结构
        * 定义主题
        * 定义属性
        * 定义服务
* **OOD模型**（对象建模技术）：
    * OOA的五个层次和五个活动贯穿在OOD中
    * 四个活动构成：
        * 设计问题域部件：OOA的结果就是OOD的问题域部件
        * 设计人机交互部件
        * 设计任务管理部件：识别事件驱动任务
        * 设计数据管理部件：目的是隔离数据管理方案对其他部件的影响

* 【OMT】
    * **OMT模型**
        * 对象模型
        * 动态模型
        * 功能模型
        * 模型关系
    * **OMT步骤**
        * **分析**：
        * **系统设计**：
            * 将系统分解成子系统
            * 标识问题中固有的并发性
            * 将子系统分配到处理器和任务
            * 选择数据存储管理的手段
            * 处理对全局资源的访问
            * 选择软件中控制的实现
            * 处理边界条件
            * 设置折中的优先级
        * **对象设计**：设计者必须履行一下步骤：
            * 综合考虑三个模型以获得类上的操作
            * 设计实现操作的算法
            * 优化数据访问路径
            * 实现与外部交互的控制
            * 调整类结构以增加继承
            * 设计关联
            * 确定对象表示
            * 将类和关联包装到模块中
        * **实现**：

****
* 【UML】
    * **事物**
        * **结构事物**：模型的静态部分，描述概念或物理元素，例如：类，接口，协作，用例，主动类，构件，节点
        * **行为事物**：UML模型的动态部分。例如：交互（消息，有向线段），状态机（对象或交互的状态，圆角矩形）
        * **分组事物**：模型分解组成的“盒子”，例如：包（概念性，仅存在开发阶段，文件夹图形）
        * **注释事物**：UML的解释部分，例如：注解
    * **视图**
        * 分为三个视图域：结构分类，动态行为，模型管理
        * **类图**（Class Diagram）:展现了一组对象，接口，协作以及之间的关系，作为静态视图，还可以包含依赖，关联，泛化，实现，注解，约束关系等
        * **用例图**（Use Case Diagram）：展现了一组用例，参与者以及两者的关系。对系统的静态用例视图建模时，可以分两种方法：对系统的语境建模，对系统的需求建模
        * **构件图**（Component Diagram）：展现了一组构建之间的组织和依赖，通常将构建映射一个或多个类、接口或协作
        * **部署图**（Deployment Diagram）：体系结构的静态实施视图，与构件图相关，通常一个节点包含一个或多个构件，类似包图
        * **状态图**（statechart Diagram）：展现了一个状态机，它由状态，转换，事件和活动组成，一般是分析一个对象
            * 状态图中的状态包括状态名、内部活动、内部转换、入口和出口动作等部分
        * **活动图**（activity Diagram）：特殊的状态图，展现了系统从一个活动到另一个活动的流程
        * **交互图** ：顺序图和协作图均被称为交互图
            * 顺序图强调消息时间序列
            * 系统的动态方面建模
        * **对象图** （Object Diagram）：静态的实例，一组对象以及它们之间的关系 一般包括对象和链
* **模式**
    * **中介者**：包装了一系列对象相互作用的方式，使得对象间的相互作用是独立变化，但是与中介者紧密联系
    * **观察者**：一个目标物件管理相依于它的管理物件，并且在它本身的状态发生改变时发出通知，这种模式常用来实现事件处理系统。


**************************************************
##【10.标准化与知识产权】
 
**************************************************
##【11.专业英语】
 
**************************************************
##【12.数据流图】
 
**************************************************
##【13.UML设计与分析】
 
状态图主要用于描述对象具有的各种状态、状态之间的转换过程以及触发状态转换的各种事件和条件。

####状态图的组成

1.1 状态

　　主要用于描述一个对象在生命周期内的一个时间段。状态图中的状态包括状态名、内部活动、内部转换、入口和出口动作等部分。

1.2 转换

　　转换是指状态之间在某种事件或条件的驱动下的切换的过程。转换分为外部转换、内部转换、完成转换、复合转换等。如下图：
![](https://raw.githubusercontent.com/Kuangcp/Notes/master/TXT/Images/UML/UML_1.jpg)
　　                        

1.3 判定

　　判定用来表示一个事件依据不同的监护条件有不同的影响。在实际建模的过程中，如果遇到需要使用判定的情况，通常用监护条件来覆盖每种可能，使得一个事件的发生能保证触发一个转换。
![](https://raw.githubusercontent.com/Kuangcp/Notes/master/TXT/Images/UML/UML_2.jpg)
　　

1.4 同步

 　　同步是为了说明并发工作流的分支与汇合。状态图和活动图中都可能用到同步。
![](https://raw.githubusercontent.com/Kuangcp/Notes/master/TXT/Images/UML/UML_3.jpg)
　　

1.5 事件

　　事件可以分成几种，主要包括：信号事件、调用事件、改变事件和时间事件等。

　　1. 信号事件（Signal Event）信号是作为两个对象之间的通信媒介的命名的实体，它以对象之间显式通信为目的。

　　2. 调用事件（Call Event）调用事件指的是一个对象对调用（Call）的接收，这个对象利用状态的转换而不是利用固定的处理过程实现操作。

　　3. 改变事件（Change Event）指的是依赖与特定属性值的布尔表达式所表示的条件满足时，事件发生改变。

　　4. 时间事件（Time Event）时间事件（Time Event）表示时间表达式被满足的事件，它代表时间的流逝。

2、组成状态

　　在一个复杂的状态中，可以细化为多个简单的子状态。这个复杂的状态就被称之为组成状态（Composite State）。

2.1 顺序组成状态
![](https://raw.githubusercontent.com/Kuangcp/Notes/master/TXT/Images/UML/UML_4.png)
　　

2.2 并发组成状态

　　（订货的状态图）
![](https://raw.githubusercontent.com/Kuangcp/Notes/master/TXT/Images/UML/UML_5.png)
　　

3 实例：团购旅游活动状态图

　　UML的模型中可分为两种，动态模型和静态模型。用例图、类图和对象图都是UML中的静态结构模型。而在UML系统动态模型的其中一种就是交互视图，它描述了执行系统功能的各个角色之间相互传递消息的顺序关系。序列图就是交互视图的一种形式。
![](https://raw.githubusercontent.com/Kuangcp/Notes/master/TXT/Images/UML/UML_6.jpg)
####序列图
1、序列图的定义

　　序列图是对对象之间传送消息的时间顺序的可视化表示。序列图的主要用途是把用例表达的需求，转化为进一步、更加正式层次的精细表达。用例常常被细化为一个或者更多的序列图。同时序列图更有效地描述如何分配各个类的职责以及各类具有相应职责的原因。

2、序列图的结构

　　序列图（Sequence Diagram）是由对象（Object）、生命线（Lifeline）、激活（Activation）、消息（Messages）、分支与从属流等元素构成的。

2.1、对象

　　对象就是指类的实例。我认为在序列图中对象有三种状态：激活、运行（存在）和销毁。
![](https://raw.githubusercontent.com/Kuangcp/Notes/master/TXT/Images/UML/UML_7.jpg)
　　　　　　　　

2.2、生命线

　　生命线（Lifeline）是一条垂直的虚线，用来表示序列图中的对象在一段时间内的存在。见上图。

2.3、激活

　　序列图可以描述对象的激活（Activation），激活是对象操作的执行，它表示一个对象直接或通过从属操作完成操作的过程。在UML图中通过一个窄长的矩形来表示，矩形的高度表示对象存在的过程。
![](https://raw.githubusercontent.com/Kuangcp/Notes/master/TXT/Images/UML/UML_8.jpg)
　　　　　　　　

2.4、消息

　　消息（Messages）是对象间的一种通信机制。由发送对象向另一个或其他几个接收对象发送信号，或由一个对象（发送者或调用者）调用另一个对象（接收者）的操作。
![](https://raw.githubusercontent.com/Kuangcp/Notes/master/TXT/Images/UML/UML_9.jpg)
　　　　　　　　

　　在UML中消息分为5类：递归调用、普通操作、返回消息、异步调用的消息、过程调用的消息。

2.5、分支与从属流

　　在UML中存在两种方式可以来修改序列图中消息的控制流，分别是：分支和从属流。

　　分支是指从同一点发出的多个消息并指向不同的对象，根据条件是否互斥，可以有条件和并行两种结构。

　　从属流指的是从同一点发出多个消息指向同一个对象的不同生命线。

3、综合示例
![](https://raw.githubusercontent.com/Kuangcp/Notes/master/TXT/Images/UML/UML_10.jpg)
**************************************************
##【14.数据库设计】
* 考试套路：
    * 1.补全ER图
    * 2.补全关系模式指明主外键
    * 3.添加一个实体，或修改关系模式。或者优化
* 考点：
    * ER图的补充，主外键的确定，业务关系的正确具体分析，模式优化（模式分解）
    * 注意：给出的ER图是不全的，可能还会少实体，关系
    * 一定要仔细检查大段的说明文字，不能遗漏关系，字段等
![ER图](https://raw.githubusercontent.com/Kuangcp/Notes/master/TXT/Images/ER.png)

**************************************************
##【15.数据结构与算法】
 
**************************************************
##【16.C++程序设计】
 
**************************************************
##【17.Java程序设计】
 
**************************************************

##  模拟题错题记录
